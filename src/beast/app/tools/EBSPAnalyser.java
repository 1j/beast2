package beast.app.tools;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import beast.math.statistic.DiscreteStatistics;

public class EBSPAnalyser {
	String m_sFileOut;
	PrintStream m_out = System.out;
	String m_sType = "Linear";
	String m_sInputFile;
	int m_nBurninPercentage = 10;

	private void run() throws Exception {
		parse(m_sInputFile, m_nBurninPercentage, m_sType, m_out);
	}

	void parse(String sFile, int nBurnInPercentage, String sType, PrintStream out) throws Exception {
		logln("Processing " + sFile);
		BufferedReader fin = new BufferedReader(new FileReader(sFile));
		String sStr;
		int nData = 0;
		// first, sweep through the log file to determine size of the log
		while (fin.ready()) {
			sStr = fin.readLine();
			if (sStr.indexOf('#') < 0 && sStr.matches(".*[0-9a-zA-Z].*")) {
				nData++;
			}
		}		
		final int nBurnIn = nData * nBurnInPercentage / 100;
		logln(" skipping " + nBurnIn + " line\n\n");
		nData = -nBurnIn - 1;
		fin = new BufferedReader(new FileReader(sFile));
		
		// process log
		final List<List<Double>> times = new ArrayList<List<Double>>();
		final List<List<Double>> popSizes = new ArrayList<List<Double>>();
		double [] alltimes = null;
		while (fin.ready()) {
			sStr = fin.readLine();
			if (sStr.indexOf('#') < 0 && sStr.matches(".*[0-9a-zA-Z].*")) {
				if (++nData > 0) {
					final String [] sStrs = sStr.split("\t");
					final List<Double> times2 = new ArrayList<Double>();
					final List<Double> popSizes2 = new ArrayList<Double>();
					if (alltimes == null) {
						alltimes = new double[sStrs.length - 1];
					}
					for (int i = 1; i < sStrs.length; i++) {
						final String [] sStrs2 = sStrs[i].split(":");
						final Double time = Double.parseDouble(sStrs2[0]);
						alltimes[i - 1] += time;
						if (sStrs2.length > 1) {
							times2.add(time);
							popSizes2.add(Double.parseDouble(sStrs2[1]));
						}
					}
					times.add(times2);
					popSizes.add(popSizes2);
					
				}
			}
		}

        if( alltimes == null ) {
            //burn-in too large?
            return;
        }

		// take average of coalescent times 
		for (int i = 0; i < alltimes.length; i++) {
			alltimes[i] /= times.size();
		}
		
		// generate output
		out.println("time\tmean\tmedian\t95HPD lower\t95HPD upper");
		final double [] popSizeAtTimeT = new double[times.size()];
        for (final double time : alltimes) {
            for (int j = 0; j < popSizeAtTimeT.length; j++) {
                popSizeAtTimeT[j] = calcPopSize(sType, times.get(j), popSizes.get(j), time);
            }
            Arrays.sort(popSizeAtTimeT);
            out.print(time + "\t");
            out.print(DiscreteStatistics.mean(popSizeAtTimeT) + "\t");
            out.print(DiscreteStatistics.median(popSizeAtTimeT) + "\t");
            out.print(DiscreteStatistics.quantile(0.025, popSizeAtTimeT) + "\t");
            out.print(DiscreteStatistics.quantile(0.975, popSizeAtTimeT) + "\t");
            out.println();
        }
	}
	
	private double calcPopSize(String sType, List<Double> xs, List<Double> ys, double d) {
		// TODO completely untested
        // assume linear
        assert sType.equals("Linear");

        final int n = xs.size();
        final double xn = xs.get(n - 1);
        if( d >= xn) {
           return ys.get(n-1);
        }

        int i = 0;
        while( d < xs.get(i) )  {
            ++i;
        }
         // d >=  xs.get(i)
        double x0 = xs.get(i);
        double x1 = xs.get(i+1);
        double y0 = ys.get(i);
        double y1 = ys.get(i+1);

        return (d * (y1-y0) + (y0*x1-y1*x0)) / (x1-x0);
	}
	
	private void parseArgs(String[] args) throws Exception {
		int i = 0;
		try {
			while (i < args.length) {
				int iOld = i;
				if (i < args.length) {
					if (args[i].equals("")) {
						i += 1;
					} else if (args[i].equals("-help") || args[i].equals("-h") || args[i].equals("--help")) {
						System.out.println(getUsage());
						System.exit(0);
					} else if (args[i].equals("-i")) {
						m_sInputFile = args[i+1];
						i += 2;
					} else if (args[i].equals("-o")) {
						m_sFileOut = args[i+1];
		                m_out = new PrintStream(m_sFileOut);
						i += 2;
					} else if (args[i].equals("-type")) {
						m_sType = args[i+1];
						i += 2;
					} else if (args[i].equals("-burnin")) {
						m_nBurninPercentage = Integer.parseInt(args[i+1]);
						i += 2;
					}
					if (i == iOld) {
						throw new Exception("Unrecognised argument");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new Exception("Error parsing command line arguments: " + Arrays.toString(args) + "\nArguments ignored\n\n" + getUsage());
		}
	}
	
	static String getUsage() {
		return "EBSPAnalyse -i <inputfile> [options]\n" +
				"analyses trace file generated by EBSP analysis\n" +
				"Options are:\n" +
				"-burnin <percentage> percent of log to consider burn in, default 10\n" +
				"-type [linear|step] type of population function\n" +
				"-o <outputfile> name of output file, default to output on stdout\n" +
				"";
	}

	protected void log(String s) {
		System.err.print(s);
	}
	protected void logln(String s) {
		System.err.println(s);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try {
			EBSPAnalyser analyser = new EBSPAnalyser();
			analyser.parseArgs(args);
			analyser.run();
		} catch (Exception e) {
			System.out.println(getUsage());
			e.printStackTrace();
		}
		
	}
}
