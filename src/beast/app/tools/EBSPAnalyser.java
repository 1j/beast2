package beast.app.tools;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import beast.math.statistic.DiscreteStatistics;

public class EBSPAnalyser {
	String m_sFileOut;
	PrintStream m_out = System.out;
	String m_sType = "Linear";
	String m_sInputFile;
	int m_nBurninPercentage = 10;

	private void run() throws Exception {
		parse(m_sInputFile, m_nBurninPercentage, m_sType, m_out);
	}

	void parse(String sFile, int nBurnInPercentage, String sType, PrintStream out) throws Exception {
		logln("Processing " + sFile);
		BufferedReader fin = new BufferedReader(new FileReader(sFile));
		String sStr;
		int nData = 0;
		// first, sweep through the log file to determine size of the log
		while (fin.ready()) {
			sStr = fin.readLine();
			if (sStr.indexOf('#') < 0 && sStr.matches(".*[0-9a-zA-Z].*")) {
				nData++;
			}
		}		
		int nBurnIn = nData * nBurnInPercentage / 100;
		logln(" skipping " + nBurnIn + " line\n\n");
		nData = -nBurnIn - 1;
		fin = new BufferedReader(new FileReader(sFile));
		
		// process log
		List<List<Double>> times = new ArrayList<List<Double>>();
		List<List<Double>> popSizes = new ArrayList<List<Double>>();
		double [] alltimes = null;
		while (fin.ready()) {
			sStr = fin.readLine();
			if (sStr.indexOf('#') < 0 && sStr.matches(".*[0-9a-zA-Z].*")) {
				if (nData > 0) {
					String [] sStrs = sStr.split("\t");
					List<Double> times2 = new ArrayList<Double>();
					List<Double> popSizes2 = new ArrayList<Double>();
					if (alltimes == null) {
						alltimes = new double[sStrs.length - 1];
					}
					for (int i = 1; i < sStrs.length; i++) {
						String [] sStrs2 = sStrs[i].split(":");
						Double time = Double.parseDouble(sStrs2[0]);
						alltimes[i - 1] += time;
						if (sStrs2.length > 1) {
							times2.add(time);
							popSizes2.add(Double.parseDouble(sStrs2[0]));
						}
					}
					times.add(times2);
					popSizes.add(popSizes2);
					
				}
			}
		}
		
		// take average of coalescent times 
		for (int i = 0; i < alltimes.length; i++) {
			alltimes[i] /= times.size();
		}
		
		// generate output
		out.println("time\tmean\tmedian\t95HPD lower\t95HPD upper");
		double [] popSizeAtTimeT = new double[times.size()]; 
		for (int i = 0; i < alltimes.length; i++) {
			for (int j = 0; j < popSizeAtTimeT.length; j++) {
				popSizeAtTimeT[j] = calcPopSize(sType, times.get(j), popSizes.get(j), alltimes[i]);
			}
			Arrays.sort(popSizeAtTimeT);
			out.print(alltimes[i] + "\t");
			out.print(DiscreteStatistics.mean(popSizeAtTimeT) + "\t");
			out.print(DiscreteStatistics.median(popSizeAtTimeT) + "\t");
			out.print(DiscreteStatistics.quantile(0.025, popSizeAtTimeT) + "\t");
			out.print(DiscreteStatistics.quantile(0.975, popSizeAtTimeT) + "\t");
			out.println();
		}		
	}
	
	private double calcPopSize(String sType, List<Double> list, List<Double> list2, double d) {
		// TODO Auto-generated method stub
		return 0;
	}
	
	private void parseArgs(String[] args) throws Exception {
		int i = 0;
		try {
			while (i < args.length) {
				int iOld = i;
				if (i < args.length) {
					if (args[i].equals("")) {
						i += 1;
					} else if (args[i].equals("-help") || args[i].equals("-h") || args[i].equals("--help")) {
						System.out.println(getUsage());
						System.exit(0);
					} else if (args[i].equals("-i")) {
						m_sInputFile = args[i+1];
						i += 2;
					} else if (args[i].equals("-o")) {
						m_sFileOut = args[i+1];
		                m_out = new PrintStream(m_sFileOut);
						i += 2;
					} else if (args[i].equals("-type")) {
						m_sType = args[i+1];
						i += 2;
					} else if (args[i].equals("-burnin")) {
						m_nBurninPercentage = Integer.parseInt(args[i+1]);
						i += 2;
					}
					if (i == iOld) {
						throw new Exception("Unrecognised argument");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new Exception("Error parsing command line arguments: " + Arrays.toString(args) + "\nArguments ignored\n\n" + getUsage());
		}
	}
	
	static String getUsage() {
		return "EBSPAnalyse -i <inputfile> [options]\n" +
				"analyses trace file generated by EBSP analysis\n" +
				"Options are:\n" +
				"-burnin <percentage> percent of log to consider burn in, default 10\n" +
				"-type [linear|step] type of population function\n" +
				"-o <outputfile> name of output file, default to output on stdout\n" +
				"";
	}

	protected void log(String s) {
		System.err.print(s);
	}
	protected void logln(String s) {
		System.err.println(s);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try {
			EBSPAnalyser analyser = new EBSPAnalyser();
			analyser.parseArgs(args);
			analyser.run();
		} catch (Exception e) {
			System.out.println(getUsage());
			e.printStackTrace();
		}
		
	}



}
