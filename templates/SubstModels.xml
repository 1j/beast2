<beast version='2.0'
       namespace='beast.app.beauti:beast.core:beast.evolution.branchratemodel:beast.evolution.speciation:beast.evolution.tree.coalescent:beast.core.util:beast.evolution.nuc:beast.evolution.operators:beast.evolution.sitemodel:beast.evolution.substitutionmodel:beast.evolution.likelihood:beast.evolution:beast.math.distributions'>

<mergewith point='substModelTemplates'>

<!-- substitution models -->
<!-- JC69 substitution model -->
        <subtemplate id='JC69' class='beast.evolution.substitutionmodel.JukesCantor' mainid='JC69.$(n)'>
<![CDATA[
        <plugin spec='JukesCantor' id='JC69.$(n)'/>
]]>
        </subtemplate>

<!-- HKY substitution model -->
        <subtemplate id='HKY' class='beast.evolution.substitutionmodel.HKY' mainid='hky.$(n)'>
<![CDATA[
        <plugin spec='HKY' id='hky.$(n)'>
            <parameter id="kappa.$(n)" name='kappa' value="2.0" lower="0.0" estimate='true'/>
            <frequencies id='estimatedFreqs.$(n)' spec='Frequencies'>
                <frequencies id='freqParameter.$(n)' spec='parameter.RealParameter' dimension='4' value='0.25' lower='0' upper='1'/>
            </frequencies>
        </plugin>

        <plugin id='KappaScaler.$(n)' spec='ScaleOperator' scaleFactor="0.5" weight="1" parameter="@kappa.$(n)"/>
        <plugin id='FrequenciesExchanger.$(n)' spec='DeltaExchangeOperator' delta="0.01" weight="0.1" parameter="@freqParameter.$(n)"/>

        <plugin id='KappaPrior.$(n)' spec='Prior' x='@kappa.$(n)'>
            <distr spec="LogNormalDistributionModel" meanInRealSpace='true'>
                <parameter name='M' value="1.0" estimate='false'/>
                <parameter name='S' value="1.25" estimate='false'/>
            </distr>
		</plugin>
<!--
        <plugin id='FrequenciesPrior.$(n)' spec='Prior' x='@freqParameter.$(n)'><distr spec="beast.math.distributions.Uniform" lower='0' upper='1'/></plugin>
-->

]]>

            <connect srcID='kappa.$(n)'                targetID='state' inputName='stateNode' if='inposterior(hky.$(n)) and kappa.$(n)/estimate=true'/>
            <connect srcID='freqParameter.$(n)'        targetID='state' inputName='stateNode' if='inposterior(hky.$(n)) and inposterior(freqParameter.$(n)) and freqParameter.$(n)/estimate=true'/>

            <connect srcID='KappaScaler.$(n)'          targetID='mcmc' inputName='operator' if='inposterior(hky.$(n)) and kappa.$(n)/estimate=true'>Scale HKY transition-transversion parameter of partition $(n)</connect>
            <connect srcID='FrequenciesExchanger.$(n)' targetID='mcmc' inputName='operator' if='inposterior(hky.$(n)) and inposterior(freqParameter.$(n)) and freqParameter.$(n)/estimate=true'>Exchange values of frequencies of partition $(n)</connect>

            <connect srcID='kappa.$(n)'                targetID='tracelog' inputName='log'  if='inposterior(hky.$(n)) and kappa.$(n)/estimate=true'/>
            <connect srcID='freqParameter.$(n)'        targetID='tracelog' inputName='log'  if='inposterior(hky.$(n)) and inposterior(freqParameter.$(n)) and freqParameter.$(n)/estimate=true'/>

            <connect srcID='KappaPrior.$(n)'           targetID='prior' inputName='distribution' if='inposterior(hky.$(n)) and kappa.$(n)/estimate=true'>HKY transition-transversion parameter of partition $(n)</connect>
<!--
            <connect srcID='FrequenciesPrior.$(n)'     targetID='prior' inputName='distribution' if='inposterior(hky.$(n)) and inposterior(freqParameter.$(n)) and freqParameter.$(n)/estimate=true'/>
-->
        </subtemplate>

<!-- GTR substitution model -->
        <subtemplate id='GTR' class='beast.evolution.substitutionmodel.GTR' mainid='gtr.$(n)' suppressInputs='beast.evolution.substitutionmodel.GTR.eigenSystem'>
<![CDATA[
        <plugin spec='GTR' id='gtr.$(n)'>
            <parameter id="rateAC.$(n)" name='rateAC' value="1.0" lower="0.0" estimate='true'/>
            <parameter id="rateAG.$(n)" name='rateAG' value="1.0" lower="0.0" estimate='true'/>
            <parameter id="rateAT.$(n)" name='rateAT' value="1.0" lower="0.0" estimate='true'/>
            <parameter id="rateCG.$(n)" name='rateCG' value="1.0" lower="0.0" estimate='true'/>
            <parameter id="rateCT.$(n)" name='rateCT' value="1.0" lower="0.0" estimate='false'/>
            <parameter id="rateGT.$(n)" name='rateGT' value="1.0" lower="0.0" estimate='true'/>
            <frequencies id='freqs.$(n)' spec='Frequencies'>
                <frequencies id='freqParameter.$(n)' spec='parameter.RealParameter' dimension='4' value='0.25' lower='0' upper='1'/>
            </frequencies>
        </plugin>

        <operator id='RateACScaler.$(n)' spec='ScaleOperator' scaleFactor="0.5" weight="1" parameter="@rateAC.$(n)"/>
        <operator id='RateAGScaler.$(n)' spec='ScaleOperator' scaleFactor="0.5" weight="1" parameter="@rateAG.$(n)"/>
        <operator id='RateATScaler.$(n)' spec='ScaleOperator' scaleFactor="0.5" weight="1" parameter="@rateAT.$(n)"/>
        <operator id='RateCGScaler.$(n)' spec='ScaleOperator' scaleFactor="0.5" weight="1" parameter="@rateCG.$(n)"/>
        <operator id='RateCTScaler.$(n)' spec='ScaleOperator' scaleFactor="0.5" weight="1" parameter="@rateCT.$(n)"/>
        <operator id='RateGTScaler.$(n)' spec='ScaleOperator' scaleFactor="0.5" weight="1" parameter="@rateGT.$(n)"/>
        <operator id='FrequenciesExchanger.$(n)' spec='DeltaExchangeOperator' delta="0.01" weight="0.1" parameter="@freqParameter.$(n)"/>

        <prior id='RateACPrior.$(n)' spec='Prior' x='@rateAC.$(n)'><distr spec="beast.math.distributions.Gamma" alpha='0.05' beta='10.0'/></prior>
        <prior id='RateAGPrior.$(n)' spec='Prior' x='@rateAG.$(n)'><distr spec="beast.math.distributions.Gamma" alpha='0.05' beta='20.0'/></prior>
        <prior id='RateATPrior.$(n)' spec='Prior' x='@rateAT.$(n)'><distr spec="beast.math.distributions.Gamma" alpha='0.05' beta='10.0'/></prior>
        <prior id='RateCGPrior.$(n)' spec='Prior' x='@rateCG.$(n)'><distr spec="beast.math.distributions.Gamma" alpha='0.05' beta='10.0'/></prior>
        <prior id='RateCTPrior.$(n)' spec='Prior' x='@rateCT.$(n)'><distr spec="beast.math.distributions.Gamma" alpha='0.05' beta='20.0'/></prior>
        <prior id='RateGTPrior.$(n)' spec='Prior' x='@rateGT.$(n)'><distr spec="beast.math.distributions.Gamma" alpha='0.05' beta='10.0'/></prior>
]]>

            <connect srcID='freqParameter.$(n)' targetID='state' inputName='stateNode' if='inposterior(gtr.$(n)) and freqParameter.$(n)/estimate=true'/>
            <connect srcID='rateAC.$(n)' targetID='state' inputName='stateNode' if='inposterior(gtr.$(n)) and rateAC.$(n)/estimate=true'/>
            <connect srcID='rateAG.$(n)' targetID='state' inputName='stateNode' if='inposterior(gtr.$(n)) and rateAG.$(n)/estimate=true'/>
            <connect srcID='rateAT.$(n)' targetID='state' inputName='stateNode' if='inposterior(gtr.$(n)) and rateAT.$(n)/estimate=true'/>
            <connect srcID='rateCG.$(n)' targetID='state' inputName='stateNode' if='inposterior(gtr.$(n)) and rateCG.$(n)/estimate=true'/>
            <connect srcID='rateCT.$(n)' targetID='state' inputName='stateNode' if='inposterior(gtr.$(n)) and rateCT.$(n)/estimate=true'/>
            <connect srcID='rateGT.$(n)' targetID='state' inputName='stateNode' if='inposterior(gtr.$(n)) and rateGT.$(n)/estimate=true'/>

            <connect srcID='FrequenciesExchanger.$(n)' targetID='mcmc' inputName='operator' if='inposterior(freqParameter.$(n)) and freqParameter.$(n)/estimate=true'>Exchange values of frequencies of partition $(n)</connect>
            <connect srcID='RateACScaler.$(n)' targetID='mcmc' inputName='operator' if='inposterior(gtr.$(n)) and rateAC.$(n)/estimate=true'>Scale GTR A-C substitution parameter of partition $(n)</connect>
            <connect srcID='RateAGScaler.$(n)' targetID='mcmc' inputName='operator' if='inposterior(gtr.$(n)) and rateAG.$(n)/estimate=true'>Scale GTR A-G substitution parameter of partition $(n)</connect>
            <connect srcID='RateATScaler.$(n)' targetID='mcmc' inputName='operator' if='inposterior(gtr.$(n)) and rateAT.$(n)/estimate=true'>Scale GTR A-T substitution parameter of partition $(n)</connect>
            <connect srcID='RateCGScaler.$(n)' targetID='mcmc' inputName='operator' if='inposterior(gtr.$(n)) and rateCG.$(n)/estimate=true'>Scale GTR C-G substitution parameter of partition $(n)</connect>
            <connect srcID='RateCTScaler.$(n)' targetID='mcmc' inputName='operator' if='inposterior(gtr.$(n)) and rateCT.$(n)/estimate=true'>Scale GTR C-T substitution parameter of partition $(n)</connect>
            <connect srcID='RateGTScaler.$(n)' targetID='mcmc' inputName='operator' if='inposterior(gtr.$(n)) and rateGT.$(n)/estimate=true'>Scale GTR G-T substitution parameter of partition $(n)</connect>

            <connect srcID='freqParameter.$(n)' targetID='tracelog' inputName='log' if='inposterior(freqParameter.$(n)) and freqParameter.$(n)/estimate=true'/>
            <connect srcID='rateAC.$(n)' targetID='tracelog' inputName='log' if='inposterior(gtr.$(n)) and rateAC.$(n)/estimate=true'/>
            <connect srcID='rateAG.$(n)' targetID='tracelog' inputName='log' if='inposterior(gtr.$(n)) and rateAG.$(n)/estimate=true'/>
            <connect srcID='rateAT.$(n)' targetID='tracelog' inputName='log' if='inposterior(gtr.$(n)) and rateAT.$(n)/estimate=true'/>
            <connect srcID='rateCG.$(n)' targetID='tracelog' inputName='log' if='inposterior(gtr.$(n)) and rateCG.$(n)/estimate=true'/>
            <connect srcID='rateCT.$(n)' targetID='tracelog' inputName='log' if='inposterior(gtr.$(n)) and rateCT.$(n)/estimate=true'/>
            <connect srcID='rateGT.$(n)' targetID='tracelog' inputName='log' if='inposterior(gtr.$(n)) and rateGT.$(n)/estimate=true'/>

            <connect srcID='RateACPrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(gtr.$(n)) and rateAC.$(n)/estimate=true'>GTR A-C substitution parameter of partition $(n)</connect>
            <connect srcID='RateAGPrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(gtr.$(n)) and rateAG.$(n)/estimate=true'>GTR A-G substitution parameter of partition $(n)</connect>
            <connect srcID='RateATPrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(gtr.$(n)) and rateAT.$(n)/estimate=true'>GTR A-T substitution parameter of partition $(n)</connect>
            <connect srcID='RateCGPrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(gtr.$(n)) and rateCG.$(n)/estimate=true'>GTR C-G substitution parameter of partition $(n)</connect>
            <connect srcID='RateCTPrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(gtr.$(n)) and rateCT.$(n)/estimate=true'>GTR C-T substitution parameter of partition $(n)</connect>
            <connect srcID='RateGTPrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(gtr.$(n)) and rateGT.$(n)/estimate=true'>GTR G-T substitution parameter of partition $(n)</connect>
        </subtemplate>


<!-- empirical amino acid substitution models -->
        <subtemplate id='Blosum62' class='beast.evolution.substitutionmodel.Blosum62' suppressInputs='beast.evolution.substitutionmodel.Blosum62.eigenSystem' mainid='Blosum62.$(n)'><!--value spec='XML'--><![CDATA[<plugin spec='Blosum62' id='Blosum62.$(n)'/>]]></subtemplate>
        <subtemplate id='Dayhoff' class='beast.evolution.substitutionmodel.Dayhoff' suppressInputs='beast.evolution.substitutionmodel.Dayhoff.eigenSystem' mainid='Dayhoff.$(n)'><!--value spec='XML'--><![CDATA[<plugin spec='Dayhoff' id='Dayhoff.$(n)'/>]]></subtemplate>
        <subtemplate id='JTT' class='beast.evolution.substitutionmodel.JTT' suppressInputs='beast.evolution.substitutionmodel.JTT.eigenSystem' mainid='JTT.$(n)'><!--value spec='XML'--><![CDATA[<plugin spec='JTT' id='JTT.$(n)'/>]]></subtemplate>
        <subtemplate id='cpREV' class='beast.evolution.substitutionmodel.CPREV' suppressInputs='beast.evolution.substitutionmodel.CPREV.eigenSystem' mainid='CPREV.$(n)'><!--value spec='XML'--><![CDATA[<plugin spec='CPREV' id='CPREV.$(n)'/>]]></subtemplate>
        <subtemplate id='mtREV' class='beast.evolution.substitutionmodel.MTREV' suppressInputs='beast.evolution.substitutionmodel.MTREV.eigenSystem' mainid='MTREV.$(n)'><!--value spec='XML'--><![CDATA[<plugin spec='MTREV' id='MTREV.$(n)'/>]]></subtemplate>
        <subtemplate id='WAG' class='beast.evolution.substitutionmodel.WAG' suppressInputs='beast.evolution.substitutionmodel.WAG.eigenSystem' mainid='WAG.$(n)'><!--value spec='XML'--><![CDATA[<plugin spec='WAG' id='WAG.$(n)'/>]]></subtemplate>

<!-- binary model -->
        <subtemplate id='MutationDeathModel' class='beast.evolution.substitutionmodel.MutationDeathModel' mainid='MutationDeathModel.$(n)'
suppressInputs="beast.evolution.substitutionmodel.MutationDeathModel.substmodel">
<![CDATA[
		<plugin id='MutationDeathModel.$(n)' spec='MutationDeathModel'>
			<parameter name='deathprob' value='0.1' estimate='false'/>
			<parameter name='mu' value='1' estimate='false'/>
		</plugin>
]]>
        </subtemplate>




<!-- frequency models -->
        <subtemplate id='Estimated' class='beast.evolution.substitutionmodel.Frequencies' mainid='estimatedFreqs.$(n)'>
<![CDATA[
            <frequencies id='estimatedFreqs.$(n)' spec='Frequencies'>
                <frequencies id='freqParameter.$(n)' spec='parameter.RealParameter' dimension='4' value='0.25' lower='0' upper='1'/>
            </frequencies>

	        <plugin id='FrequenciesExchanger.$(n)' spec='DeltaExchangeOperator' delta="0.01" weight="0.1" parameter="@freqParameter.$(n)"/>
]]>
            <connect srcID='freqParameter.$(n)' targetID='state' inputName='stateNode' if='inposterior(estimatedFreqs.$(n)) and freqParameter.$(n)/estimate=true'/>
            <connect srcID='FrequenciesExchanger.$(n)' targetID='mcmc' inputName='operator' if='inposterior(estimatedFreqs.$(n)) and freqParameter.$(n)/estimate=true'>Exchange values of frequencies of partition $(n)</connect>
            <connect srcID='freqParameter.$(n)' targetID='tracelog' inputName='log' if='inposterior(estimatedFreqs.$(n)) and freqParameter.$(n)/estimate=true'/>
        </subtemplate>

        <subtemplate id='Empirical' class='beast.evolution.substitutionmodel.Frequencies' mainid='empiricalFreqs.$(n)'>
<![CDATA[
            <frequencies id='empiricalFreqs.$(n)' spec='Frequencies' data='@$(n)' estimate='true'/>
]]>
        </subtemplate>

        <subtemplate id='AllEqual' class='beast.evolution.substitutionmodel.Frequencies' mainid='equalFreqs.$(n)'>
<![CDATA[
            <frequencies id='equalFreqs.$(n)' spec='Frequencies' data='@$(n)' estimate='false'/>
]]>
        </subtemplate>
</mergewith>


<!-- Clock models -->
<mergewith point='clockModelTemplates'>

<!-- Strickt clock -->
        <subtemplate id='StrictClock' class='beast.evolution.branchratemodel.StrictClockModel' mainid='StrictClock.$(n)'>
<![CDATA[
                <branchRateModel spec='StrictClockModel' id='StrictClock.$(n)'>
                    <clock.rate id='clockRate.$(n)' spec='parameter.RealParameter' value='1.0' estimate='false'/>
                </branchRateModel>

				<operator id='StrictClockRateScaler.$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter='@clockRate.$(n)'/>
   			    <!-- need updown operator for clockRate?!? Also in Standard.xml -->

		        <plugin id='ClockPrior.$(n)' spec='Prior' x='@clockRate.$(n)'><distr spec="OneOnX"/></plugin>
]]>
            <connect srcID='clockRate.$(n)' targetID='state' inputName='stateNode' if='inposterior(StrictClock.$(n)) and clockRate.$(n)/estimate=true'/>

            <connect srcID='clockRate.$(n)'  targetID='state' inputName='stateNode'          if='inposterior(StrictClock.$(n)) and clockRate.$(n)/estimate=true'/>
            <connect srcID='ClockPrior.$(n)' targetID='prior' inputName='distribution'       if='inposterior(StrictClock.$(n)) and clockRate.$(n)/estimate=true'>substitution rate of partition $(n)</connect>
            <connect srcID='StrictClockRateScaler.$(n)' targetID='mcmc' inputName='operator' if='inposterior(StrictClock.$(n)) and clockRate.$(n)/estimate=true'>Scale substitution rate of partition $(n)</connect>
        </subtemplate>

<!-- Relaxed clock exponential -->
        <subtemplate id='RelaxedClockExponential' class='beast.evolution.branchratemodel.UCRelaxedClockModel' mainid='ExponentialRelaxedClock.$(n)'>
<![CDATA[
        <plugin spec='UCRelaxedClockModel' id="ExponentialRelaxedClock.$(n)" tree='@Tree.$(n)'>
			<parameter name='clock.rate' id='ucedMean.$(n)' value='1.0' estimate='false'/>
            <distr id='Exponential.$(n)' name='distr' spec="beast.math.distributions.Exponential">
				<parameter id='UCExpLambda' name='lambda' value='1.0'/>
			</distr>
            <rateCategories spec='parameter.IntegerParameter' id='expRateCategories.$(n)' value="1" dimension='10' estimate='true'/>
        </plugin>

        <operator id='ucedMeanScaler.$(n)' spec='ScaleOperator' scaleAll='false' scaleFactor="0.5" weight="1" parameter="@ucedMean.$(n)"/>
        <operator id="ExpCategoriesRandomWalk.$(n)" spec="IntRandomWalkOperator" windowSize='1' weight="10" parameter="@expRateCategories.$(n)"/>
		<operator id='ExpCategoriesSwapOperator.$(n)' spec='SwapOperator' howMany="1" weight="10" intparameter='@expRateCategories.$(n)'/>
		<operator id='ExpCategoriesUniform.$(n)' spec='UniformOperator' weight="10" parameter='@expRateCategories.$(n)'/>

		<upDownOperator id='relaxedUpDownOperatorExp.$(n)' spec='UpDownOperator' scaleFactor="0.75" weight="3">
			<up idref="ucedMean.$(n)"/>
			<down idref="Tree.$(n)"/>
		</upDownOperator>

		<log id='rateStat.$(n)' spec='RateStatistic' tree='@Tree.$(n)' branchratemodel='@ExponentialRelaxedClock.$(n)'/>
        <plugin id='UCMeanRatePrior.$(n)' spec='Prior' x='@ucedMean.$(n)'><distr spec="OneOnX"/></plugin>
]]>
            <connect srcID='ucedMean.$(n)' targetID='state' inputName='stateNode' if='inposterior(ExponentialRelaxedClock.$(n)) and ucedMean.$(n)/estimate=true'/>
            <connect srcID='expRateCategories.$(n)' targetID='state' inputName='stateNode' if='inposterior(ExponentialRelaxedClock.$(n))'/>

            <connect srcID='UCMeanRatePrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(ExponentialRelaxedClock.$(n)) and ucedMean.$(n)/estimate=true'>uncorrelated exponential relaxed clock mean of partition $(n)</connect>

            <connect srcID='ucedMeanScaler.$(n)'            targetID='mcmc' inputName='operator' if='inposterior(ExponentialRelaxedClock.$(n)) and ucedMean.$(n)/estimate=true'>Scale clock rate of partition $(n)</connect>
            <connect srcID='ExpCategoriesRandomWalk.$(n)'   targetID='mcmc' inputName='operator' if='inposterior(ExponentialRelaxedClock.$(n))'>Randomly change categories of partition $(n)</connect>
            <connect srcID='ExpCategoriesSwapOperator.$(n)' targetID='mcmc' inputName='operator' if='inposterior(ExponentialRelaxedClock.$(n))'>Swap categories of partition $(n)</connect>
            <connect srcID='ExpCategoriesUniform.$(n)'      targetID='mcmc' inputName='operator' if='inposterior(ExponentialRelaxedClock.$(n))'>Uniformly draw categories of partition $(n)</connect>
            <connect srcID='relaxedUpDownOperatorExp.$(n)'  targetID='mcmc' inputName='operator' if='inposterior(ExponentialRelaxedClock.$(n)) and ucedMean.$(n)/estimate=true and Tree.$(n)/estimate=true'>Up/down scaler for mean rate and tree of partition $(n)</connect>

            <connect srcID='ucedMean.$(n)' targetID='tracelog' inputName='log' if='inposterior(ExponentialRelaxedClock.$(n)) and ucedMean.$(n)/estimate=true'/>
            <connect srcID='rateStat.$(n)' targetID='tracelog' inputName='log' if='inposterior(ExponentialRelaxedClock.$(n))'/>

        </subtemplate>


<!-- Relaxed clock log normal -->
        <subtemplate id='RelaxedClockLogNormal' class='beast.evolution.branchratemodel.UCRelaxedClockModel' mainid='RelaxedClock.$(n)'>
<![CDATA[
        <plugin spec='UCRelaxedClockModel' id="RelaxedClock.$(n)" tree='@Tree.$(n)'>
			<parameter name='clock.rate' id='ucldMean.$(n)' value='1.0'/>
            <distr id='LogNormalDistributionModel.$(n)' name='distr' spec="beast.math.distributions.LogNormalDistributionModel" meanInRealSpace='true'>
                <parameter name='M' value="1.0" estimate='false' lower='0' upper='1'/>
                <parameter name='S' id='ucldStdev.$(n)' value="0.5" lower="0" upper="5" estimate='true'/>
            </distr>
            <rateCategories spec='parameter.IntegerParameter' id='rateCategories.$(n)' value="1" dimension='10' estimate='true'/>
        </plugin>

        <operator id='ucldMeanScaler.$(n)' spec='ScaleOperator' scaleAll='false' scaleFactor="0.5" weight="1" parameter="@ucldMean.$(n)"/>
        <operator id='ucldStdevScaler.$(n)' spec='ScaleOperator' scaleAll='false' scaleFactor="0.5" weight="1" parameter="@ucldStdev.$(n)"/>
        <operator id="CategoriesRandomWalk.$(n)" spec="IntRandomWalkOperator" windowSize='1' weight="10" parameter="@rateCategories.$(n)"/>
		<operator id='CategoriesSwapOperator.$(n)' spec='SwapOperator' howMany="1" weight="10" intparameter='@rateCategories.$(n)'/>
		<operator id='CategoriesUniform.$(n)' spec='UniformOperator' weight="10" parameter='@rateCategories.$(n)'/>

		<upDownOperator id='relaxedUpDownOperator.$(n)' spec='UpDownOperator' scaleFactor="0.75" weight="3">
			<up idref="ucldMean.$(n)"/>
			<down idref="Tree.$(n)"/>
		</upDownOperator>

        <prior id='ucldStdevPrior.$(n)' spec='Prior' x='@ucldStdev.$(n)'>
            <distr spec="beast.math.distributions.Exponential">
                <parameter name='lambda' value="0.3333" estimate='false'/>
            </distr>
        </prior>


		<log id='rate.$(n)' spec='RateStatistic' tree='@Tree.$(n)' branchratemodel='@RelaxedClock.$(n)'/>
        <plugin id='MeanRatePrior.$(n)' spec='Prior' x='@ucldMean.$(n)'><distr spec="OneOnX"/></plugin>
]]>
            <connect srcID='ucldMean.$(n)' targetID='state' inputName='stateNode' if='inposterior(RelaxedClock.$(n)) and ucldMean.$(n)/estimate=true'/>
            <connect srcID='ucldStdev.$(n)' targetID='state' inputName='stateNode' if='inposterior(RelaxedClock.$(n)) and ucldStdev.$(n)/estimate=true'/>
            <connect srcID='rateCategories.$(n)' targetID='state' inputName='stateNode' if='inposterior(RelaxedClock.$(n))'/>

            <connect srcID='ucldMeanScaler.$(n)'         targetID='mcmc' inputName='operator' if='inposterior(RelaxedClock.$(n)) and ucldMean.$(n)/estimate=true'>Scale clock rate of partition $(n)</connect>
            <connect srcID='ucldStdevScaler.$(n)'        targetID='mcmc' inputName='operator' if='inposterior(RelaxedClock.$(n))'>Scale stdev of rate of partition $(n)</connect>
            <connect srcID='CategoriesRandomWalk.$(n)'   targetID='mcmc' inputName='operator' if='inposterior(RelaxedClock.$(n))'>Randomly change categories of partition $(n)</connect>
            <connect srcID='CategoriesSwapOperator.$(n)' targetID='mcmc' inputName='operator' if='inposterior(RelaxedClock.$(n))'>Swap categories of partition $(n)</connect>
            <connect srcID='CategoriesUniform.$(n)'      targetID='mcmc' inputName='operator' if='inposterior(RelaxedClock.$(n))'>Uniformly draw categories of partition $(n)</connect>
            <connect srcID='relaxedUpDownOperator.$(n)'  targetID='mcmc' inputName='operator' if='inposterior(RelaxedClock.$(n)) and ucldMean.$(n)/estimate=true and Tree.$(n)/estimate=true'>Up/down scaler for mean rate and tree of partition $(n)</connect>

            <connect srcID='ucldMean.$(n)'  targetID='tracelog' inputName='log' if='inposterior(RelaxedClock.$(n)) and ucldMean.$(n)/estimate=true'/>
            <connect srcID='ucldStdev.$(n)' targetID='tracelog' inputName='log' if='inposterior(RelaxedClock.$(n))'/>
            <connect srcID='rate.$(n)'      targetID='tracelog' inputName='log' if='inposterior(RelaxedClock.$(n))'/>

            <connect srcID='ucldStdevPrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(RelaxedClock.$(n))'>uncorrelated lognormal relaxed clock stdev of partition $(n)</connect>
            <connect srcID='MeanRatePrior.$(n)'  targetID='prior' inputName='distribution' if='inposterior(RelaxedClock.$(n)) and ucldMean.$(n)/estimate=true'>uncorrelated lognormal relaxed clock mean of partition $(n)</connect>
        </subtemplate>


<!-- Random local clock -->
        <subtemplate id='RandomLocalClock' class='beast.evolution.branchratemodel.RandomLocalClockModel' mainid='RandomLocalClock.$(n)'>
<![CDATA[
        <input spec='RandomLocalClockModel' id="RandomLocalClock.$(n)" ratesAreMultipliers="false" tree='@Tree.$(n)'>
            <clock.rate id='meanClockRate.$(n)' spec='parameter.RealParameter' value='1.0' estimate='false'/>
            <parameter spec='parameter.BooleanParameter' name='indicators' id='Indicators.$(n)' value="1"/>
            <parameter name='rates' id='clockrates.$(n)' value="1"/>
        </input>

        <operator id="IndicatorsBitFlip.$(n)" spec="BitFlipOperator" weight="1" parameter="@Indicators.$(n)"/>
<!-- this should probably be a DeltaExchange instead of scale operator to keep mean rate to 1 -->
        <operator id='ClockRateScaler.$(n)' spec='ScaleOperator' scaleAll='false' scaleFactor="0.5" weight="1" parameter="@clockrates.$(n)"/>

        <operator id='randomClockScaler.$(n)' spec='ScaleOperator' scaleAll='false' scaleFactor="0.5" weight="1" parameter="@meanClockRate.$(n)"/>
		<upDownOperator id='randomClockUpDownOperator.$(n)' spec='UpDownOperator' scaleFactor="0.75" weight="3">
			<up idref="meanClockRate.$(n)"/>
			<down idref="Tree.$(n)"/>
		</upDownOperator>

        <plugin id='MeanRRatePrior.$(n)' spec='Prior' x='@meanClockRate.$(n)'><distr spec="OneOnX"/></plugin>
]]>
            <connect srcID='Indicators.$(n)' targetID='state' inputName='stateNode' if='inposterior(Indicators.$(n))'/>
            <connect srcID='meanClockRate.$(n)' targetID='state' inputName='stateNode' if='inposterior(meanClockRate.$(n)) and meanClockRate.$(n)/estimate=true'/>
            <connect srcID='clockrates.$(n)' targetID='state' inputName='stateNode' if='inposterior(clockrates.$(n))'/>


            <connect srcID='randomClockScaler.$(n)'         targetID='mcmc' inputName='operator' if='inposterior(RandomLocalClock.$(n))'>Scale clock rate of partition $(n)</connect>
            <connect srcID='randomClockUpDownOperator.$(n)' targetID='mcmc' inputName='operator' if='inposterior(RandomLocalClock.$(n)) and meanClockRate.$(n)/estimate=true'>Up/down scaler for mean rate and tree of partition $(n)</connect>
            <connect srcID='IndicatorsBitFlip.$(n)'         targetID='mcmc' inputName='operator' if='inposterior(RandomLocalClock.$(n))'>Flip indicator bits for random clock of partition $(n)</connect>
            <connect srcID='ClockRateScaler.$(n)'           targetID='mcmc' inputName='operator' if='inposterior(RandomLocalClock.$(n))'>Scale random clock rates of partition $(n)</connect>

            <connect srcID='Indicators.$(n)'                targetID='tracelog' inputName='log' if='inposterior(RandomLocalClock.$(n))'/>
            <connect srcID='clockrates.$(n)'                targetID='tracelog' inputName='log' if='inposterior(RandomLocalClock.$(n))'/>
            <connect srcID='meanClockRate.$(n)'             targetID='tracelog' inputName='log' if='inposterior(RandomLocalClock.$(n)) and meanClockRate.$(n)/estimate=true'/>

            <connect srcID='MeanRRatePrior.$(n)'            targetID='prior' inputName='distribution' if='inposterior(RandomLocalClock.$(n)) and meanClockRate.$(n)/estimate=true'>substitution rate of partition $(n)</connect>
        </subtemplate>

</mergewith>


<!-- tree priors -->
<mergewith point='treePriorTemplates'>
<!-- Yule -->
        <subtemplate id='YuleModel' class='beast.evolution.speciation.YuleModel' mainid='YuleModel.$(n)'>
<![CDATA[
            <plugin spec='YuleModel' id="YuleModel.$(n)" tree='@Tree.$(n)'>
                <parameter name='birthDiffRate' id="birthRate.$(n)" value='1.0'/>
            </plugin>

            <prior id='YuleBirthRatePrior.$(n)' spec='Prior' x='@birthRate.$(n)'><distr spec="beast.math.distributions.Uniform" lower='0' upper='1000'/></prior>

  		    <scale id='YuleBirthRateScaler.$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@birthRate.$(n)"/>
]]>
            <connect srcID='YuleModel.$(n)' targetID='prior' inputName='distribution' if='inposterior(YuleModel.$(n)) and Tree.$(n)/estimate=true'>Yule speciation prior on tree $(n)</connect>
            <connect srcID='birthRate.$(n)' targetID='state' inputName='stateNode' if='inposterior(YuleModel.$(n)) and birthRate.$(n)/estimate=true'/>

            <connect srcID='YuleBirthRatePrior.$(n)' targetID='prior' inputName='distribution' if='inposterior(YuleModel.$(n)) and birthRate.$(n)/estimate=true'>Yule speciation process birth rate of partition $(n)</connect>
            <connect srcID='YuleBirthRateScaler.$(n)' targetID='mcmc' inputName='operator'     if='inposterior(YuleModel.$(n)) and birthRate.$(n)/estimate=true'>Scale birth rate of Yule prior of tree $(n)</connect>

            <connect srcID='YuleModel.$(n)' targetID='tracelog' inputName='log' if='inposterior(YuleModel.$(n)) and Tree.$(n)/estimate=true'/>
            <connect srcID='birthRate.$(n)' targetID='tracelog' inputName='log' if='inposterior(YuleModel.$(n)) and birthRate.$(n)/estimate=true'/>
        </subtemplate>


<!-- Birth Death model according to Gernhard'08 -->
        <subtemplate id='BirthDeathModel' class='beast.evolution.speciation.BirthDeathGernhard08Model' mainid='BirthDeath.$(n)'>
<![CDATA[
            <distribution id="BirthDeath.$(n)" spec="speciation.BirthDeathGernhard08Model" tree='@Tree.$(n)'>
                <birthDiffRate spec='parameter.RealParameter' id="birthRate2.$(n)" value='1' lower='0' upper='10000' />
            	<relativeDeathRate spec='parameter.RealParameter' id="relativeDeathRate2.$(n)" value='0.5' lower='0' upper='1' />
            </distribution>

            <prior id='BirthRatePrior.$(n)' spec='Prior' x='@birthRate2.$(n)'><distr spec="beast.math.distributions.Uniform" lower='0' upper='1000'/></prior>
            <prior id='DeathRatePrior.$(n)' spec='Prior' x='@relativeDeathRate2.$(n)'><distr spec="beast.math.distributions.Uniform" lower='0' upper='1'/></prior>

  		    <scale id='BirthRateScaler.$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@birthRate2.$(n)"/>
  		    <scale id='DeathRateScaler.$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@relativeDeathRate2.$(n)"/>
]]>
            <connect srcID='BirthDeath.$(n)'         targetID='prior' inputName='distribution' if='inposterior(BirthDeath.$(n)) and Tree.$(n)/estimate=true'>Birth-Death speciation prior on tree $(n)</connect>
            <connect srcID='birthRate2.$(n)'         targetID='state' inputName='stateNode' if='inposterior(BirthDeath.$(n)) and birthRate2.$(n)/estimate=true'/>
            <connect srcID='relativeDeathRate2.$(n)' targetID='state' inputName='stateNode' if='inposterior(BirthDeath.$(n)) and relativeDeathRate2.$(n)/estimate=true'/>

            <connect srcID='BirthRatePrior.$(n)'     targetID='prior' inputName='distribution' if='inposterior(BirthDeath.$(n)) and birthRate2.$(n)/estimate=true'>Birth-Death speciation process rate of partition $(n)</connect>
            <connect srcID='DeathRatePrior.$(n)'     targetID='prior' inputName='distribution' if='inposterior(BirthDeath.$(n)) and relativeDeathRate2.$(n)/estimate=true'>Death/Birth speciation process relative death rate of partition $(n)</connect>

            <connect srcID='BirthRateScaler.$(n)'    targetID='mcmc' inputName='operator' if='inposterior(BirthDeath.$(n)) and birthRate2.$(n)/estimate=true'>Scale Death-Birth rate of Yule prior of tree $(n)</connect>
            <connect srcID='DeathRateScaler.$(n)'    targetID='mcmc' inputName='operator' if='inposterior(BirthDeath.$(n)) and relativeDeathRate2.$(n)/estimate=true'>Scale Death/Birth rate of Yule prior of tree $(n)</connect>

            <connect srcID='BirthDeath.$(n)'         targetID='tracelog' inputName='log' if='inposterior(BirthDeath.$(n)) and Tree.$(n)/estimate=true'/>
            <connect srcID='birthRate2.$(n)'         targetID='tracelog' inputName='log' if='inposterior(BirthDeath.$(n)) and birthRate2relativeDeathRaten)/estimate=true'/>
            <connect srcID='relativeDeathRate2.$(n)' targetID='tracelog' inputName='log' if='inposterior(BirthDeath.$(n)) and birthRate2.$(n)/estimate=true'/>
        </subtemplate>



<!-- Coalescent for Constant population -->
        <subtemplate id='CoalescentConstantPopulation' class='beast.evolution.tree.coalescent.Coalescent' mainid='CoalescentConstant.$(n)'>
<![CDATA[
            <distribution id="CoalescentConstant.$(n)" spec="Coalescent">
                <treeIntervals spec='TreeIntervals' id='TreeIntervals.$(n)' tree='@Tree.$(n)'/>
                <populationModel spec="ConstantPopulation" id='ConstantPopulation.$(n)'>
                     <parameter name="popSize" id="popSize.$(n)" value='0.3' estimate='true'/>
                 </populationModel>
            </distribution>

  		    <operator id='PopSizeScaler.$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@popSize.$(n)"/>
	        <prior id='PopSizePrior.$(n)' spec='Prior' x='@popSize.$(n)'><distr spec="OneOnX"/></prior>
]]>
            <connect srcID='CoalescentConstant.$(n)' targetID='prior' inputName='distribution' if='inposterior(CoalescentConstant.$(n)) and Tree.$(n)/estimate=true'>Coalescent prior with constant rate on tree $(n)</connect>
            <connect srcID='PopSizePrior.$(n)'      targetID='prior' inputName='distribution' if='inposterior(CoalescentConstant.$(n)) and popSize.$(n)/estimate=true'>Coalescent population size parameter of partition $(n)</connect>

            <connect srcID='popSize.$(n)'           targetID='state' inputName='stateNode' if='inposterior(CoalescentConstant.$(n)) and popSize.$(n)/estimate=true'/>

            <connect srcID='PopSizeScaler.$(n)'     targetID='mcmc' inputName='operator' if='inposterior(CoalescentConstant.$(n)) and popSize.$(n)/estimate=true'>Scale population size of Coalescent prior of tree $(n)</connect>

            <connect srcID='popSize.$(n)'           targetID='tracelog' inputName='log' if='inposterior(CoalescentConstant.$(n)) and popSize.$(n)/estimate=true'/>
            <connect srcID='CoalescentConstant.$(n)' targetID='tracelog' inputName='log' if='inposterior(CoalescentConstant.$(n)) and Tree.$(n)/estimate=true'/>
        </subtemplate>


<!-- Coalescent for Exponential population -->
        <subtemplate id='CoalescentExponentialPopulation' class='beast.evolution.tree.coalescent.Coalescent' mainid='CoalescentExponential.$(n)'>
<![CDATA[
            <distribution id="CoalescentExponential.$(n)" spec="Coalescent">
                <treeIntervals spec='TreeIntervals' id='TreeIntervals.$(n)' tree='@Tree.$(n)'/>
                <populationModel spec="ExponentialGrowth" id="ExponentialGrowth.$(n)">
                    <parameter name="popSize" id="ePopSize.$(n)" value='0.3' estimate='true'/>
                    <parameter name="growthRate" id="growthRate.$(n)" value='3e-4' estimate='true'/>
                </populationModel>
            </distribution>

  		    <operator id='ePopSizeScaler.$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="3" parameter="@ePopSize.$(n)"/>
	        <operator id="GrowthRateRandomWalk.$(n)" spec="RealRandomWalkOperator" windowSize='1' weight="3" parameter="@growthRate.$(n)"/>

	        <prior id='ePopSizePrior.$(n)' spec='Prior' x='@ePopSize.$(n)'><distr spec="OneOnX"/></prior>
	        <prior id='GrowthRatePrior.$(n)' spec='Prior' x='@growthRate.$(n)'><distr spec="LaplaceDistribution" mu='0.001' scale='30.701135'/></prior>

]]>
            <connect srcID='CoalescentExponential.$(n)' targetID='prior' inputName='distribution' if='inposterior(CoalescentExponential.$(n)) and Tree.$(n)/estimate=true'>Coalesenct prior with exponential rate on tree $(n)</connect>
            <connect srcID='ePopSizePrior.$(n)'         targetID='prior' inputName='distribution' if='inposterior(CoalescentExponential.$(n)) and ePopSize.$(n)/estimate=true'>Coalescent population size parameter of partition $(n)</connect>
            <connect srcID='GrowthRatePrior.$(n)'       targetID='prior' inputName='distribution' if='inposterior(CoalescentExponential.$(n)) and growthRate.$(n)/estimate=true'>Coalescent growth rate of partition $(n)</connect>

            <connect srcID='ePopSize.$(n)'              targetID='state' inputName='stateNode' if='inposterior(CoalescentExponential.$(n)) and ePopSize.$(n)/estimate=true'/>
            <connect srcID='growthRate.$(n)'            targetID='state' inputName='stateNode' if='inposterior(CoalescentExponential.$(n)) and growthRate.$(n)/estimate=true'/>

            <connect srcID='ePopSizeScaler.$(n)'        targetID='mcmc' inputName='operator' if='inposterior(CoalescentExponential.$(n)) and ePopSize.$(n)/estimate=true'>Scale population size of Coalescent prior of tree $(n)</connect>
            <connect srcID='GrowthRateRandomWalk.$(n)'  targetID='mcmc' inputName='operator' if='inposterior(CoalescentExponential.$(n)) and growthRate.$(n)/estimate=true'>Scale growth rate of Coalescent prior of tree $(n)</connect>

            <connect srcID='CoalescentExponential.$(n)' targetID='tracelog' inputName='log' if='inposterior(CoalescentExponential.$(n)) and Tree.$(n)/estimate=true'/>
            <connect srcID='ePopSize.$(n)'              targetID='tracelog' inputName='log' if='inposterior(CoalescentExponential.$(n)) and ePopSize.$(n)/estimate=true'/>
            <connect srcID='growthRate.$(n)'            targetID='tracelog' inputName='log' if='inposterior(CoalescentExponential.$(n)) and growthRate.$(n)/estimate=true'/>
        </subtemplate>


<!-- Coalescent for Bayesian skyline -->
        <subtemplate id='CoalescentBayesianSkyline' class='beast.evolution.tree.coalescent.Coalescent' mainid='BayesianSkyline.$(n)'>
<![CDATA[
            <distribution spec="BayesianSkyline" id='BayesianSkyline.$(n)'>
                <parameter name='popSizes' id='bPopSizes.$(n)' dimension="5" value="380.0" lower="0.0" upper="380000.0" estimate='true'/>
                <groupSizes spec='parameter.IntegerParameter' id='bGroupSizes.$(n)' dimension='5' value='1' estimate='true'/>
                <treeIntervals spec='TreeIntervals' id='BSPTreeIntervals.$(n)' tree='@Tree.$(n)'/>
            </distribution>

            <distribution id='MarkovChainedPopSizes.$(n)' spec="beast.math.distributions.MarkovChainDistribution" 
				jeffreys="true"
				parameter="@bPopSizes.$(n)"/>

		    <operator id='popSizesScaler.$(n)' spec='ScaleOperator' scaleFactor="0.75" weight="15" parameter="@bPopSizes.$(n)"/>
		    <operator id='groupSizesDelta.$(n)' spec='DeltaExchangeOperator' delta="1" weight="6" integer="true"
		              intparameter="@bGroupSizes.$(n)"/>

]]>
            <connect srcID='BayesianSkyline.$(n)' targetID='prior' inputName='distribution' if='inposterior(BayesianSkyline.$(n)) and Tree.$(n)/estimate=true'>Coalescent with Bayesian skyline prior tree $(n)</connect>
            <connect srcID='bPopSizes.$(n)' targetID='state' inputName='stateNode' if='inposterior(bPopSizes.$(n))'/>
            <connect srcID='bGroupSizes.$(n)' targetID='state' inputName='stateNode' if='inposterior(bGroupSizes.$(n))'/>

            <connect srcID='MarkovChainedPopSizes.$(n)' targetID='prior' inputName='distribution' if='inposterior(BayesianSkyline.$(n))'>Markov chained prior on population sizes of Bayesian skyline plot</connect>

            <connect srcID='BayesianSkyline.$(n)' targetID='tracelog' inputName='log' if='inposterior(BayesianSkyline.$(n))'/>
            <connect srcID='bPopSizes.$(n)'       targetID='tracelog' inputName='log' if='inposterior(BayesianSkyline.$(n))'/>
            <connect srcID='bGroupSizes.$(n)'     targetID='tracelog' inputName='log' if='inposterior(BayesianSkyline.$(n))'/>

            <connect srcID='popSizesScaler.$(n)'  targetID='mcmc' inputName='operator' if='inposterior(BayesianSkyline.$(n))'>Scale population size of Coalscent prior of tree $(n)</connect>
            <connect srcID='groupSizesDelta.$(n)' targetID='mcmc' inputName='operator' if='inposterior(BayesianSkyline.$(n))'>Exchange group sizes of Coalscent prior of tree $(n)</connect>
        </subtemplate>


<!-- Coalescent for Extended Bayesian skyline -->
        <subtemplate id='CoalescentExtendedBayesianSkyline' class='beast.evolution.tree.coalescent.Coalescent' mainid='ExtendedBayesianSkyline.$(n)'>
<![CDATA[
	        <stateNode id="indicators.alltrees" spec="parameter.BooleanParameter" value="false"/>
            <stateNode id="populationMean.alltrees" spec="parameter.RealParameter" value="1"/>
	        <stateNode id="popSizes.alltrees" spec="parameter.RealParameter" value="1"/>

            <distribution id="ExtendedBayesianSkyline.$(n)" spec="Coalescent">
                 <treeIntervals id="treeIntervals.$(n)" spec="TreeIntervals" tree="@Tree.$(n)"/>
                 <populationModel id="scaledDemo.$(n)" spec="beast.evolution.tree.coalescent.ScaledPopulationFunction" factor='1' population='@demographic.alltrees'/>
            </distribution>

            <population id="demographic.alltrees" populationIndicators="@indicators.alltrees" populationSizes="@popSizes.alltrees" spec="beast.evolution.tree.coalescent.CompoundPopulationFunction" type="linear" useIntervalsMiddle="false">
                <itree idref="treeIntervals.$(n)"/>
			</population>

            <distribution id="populationMeanPrior.alltrees" spec="Prior" x="@populationMean.alltrees">
                <distr spec="OneOnX" id='OneOnX.EBSP'/>
            </distribution>
            <distribution id="indicatorsPrior.alltrees" spec="Prior">
                <x arg="@indicators.alltrees" id="indsSun.alltrees" spec="util.Sum"/>
                <distr spec="Poisson"  id='Poisson.EBSP'>
                    <parameter name="lambda" upper="0.0" value="0.69314718056" estimate='false'/>
                </distr>
            </distribution>
            <distribution id="popSizePrior.alltrees" spec="Prior" x="@popSizes.alltrees">
                <distr id="popPriorDist.EBSP" lambda="@populationMean.alltrees" spec="Exponential"/>
            </distribution>

			<logger id="EBSPLogger" fileName='EBSP.$(seed).log' logEvery='5000'>
				<log idref='demographic.alltrees'/>
			</logger>

			<operator id="bitflip.alltrees" parameter="@indicators.alltrees" spec="BitFlipOperator" uniform="true" weight="1.0"/>
			<operator id="indicatorSampler.alltrees" dist="@popPriorDist.alltrees" indicators="@indicators.alltrees" spec="beast.evolution.tree.coalescent.SampleOffValues" values="@popSizes.alltrees" weight="15.0"/>
			<operator id="indicatorScaler.alltrees" degreesOfFreedom="1" indicator="@indicators.alltrees" parameter="@popSizes.alltrees" scaleAll="false" scaleAllIndependently="false" scaleFactor="0.5" spec="ScaleOperator" weight="15.0"/>
			<operator id="EBSPupDownOperator.alltrees" scaleFactor="0.7" spec="UpDownOperator" weight="5.0">
				<up idref="popSizes.alltrees"/>
				<up idref="populationMean.alltrees"/>
			</operator>
]]>
            <connect srcID='ExtendedBayesianSkyline.$(n)' targetID='prior' inputName='distribution' if='inposterior(ExtendedBayesianSkyline.$(n)) and Tree.$(n)/estimate=true'>Coalescent with extended Bayesian skyline prior tree $(n)</connect>
            <connect srcID='treeIntervals.$(n)' targetID='demographic.alltrees' inputName='itree' if='inposterior(ExtendedBayesianSkyline.$(n)) and Tree.$(n)/estimate=true'/>

            <connect srcID='indicators.alltrees'     targetID='state' inputName='stateNode' if='inposterior(ExtendedBayesianSkyline.$(n))'/>
            <connect srcID='populationMean.alltrees' targetID='state' inputName='stateNode' if='inposterior(ExtendedBayesianSkyline.$(n))'/>
            <connect srcID='popSizes.alltrees'       targetID='state' inputName='stateNode' if='inposterior(ExtendedBayesianSkyline.$(n))'/>

            <connect srcID='populationMeanPrior.alltrees' targetID='prior' inputName='distribution' if='inposterior(ExtendedBayesianSkyline.$(n))'>Extended Bayesian Skyline population prior mean of partition $(n)</connect>
            <connect srcID='indicatorsPrior.alltrees'     targetID='prior' inputName='distribution' if='inposterior(ExtendedBayesianSkyline.$(n))'>Average number of population change points of partition $(n)</connect>
            <connect srcID='popSizePrior.alltrees'        targetID='prior' inputName='distribution' if='inposterior(ExtendedBayesianSkyline.$(n))'>Extended Bayesian Skyline population prior of partition $(n)</connect>

            <connect srcID='indicators.alltrees'     targetID='tracelog' inputName='log' if='inposterior(ExtendedBayesianSkyline.$(n))'/>
            <connect srcID='populationMean.alltrees' targetID='tracelog' inputName='log' if='inposterior(ExtendedBayesianSkyline.$(n))'/>
            <connect srcID='popSizes.alltrees'       targetID='tracelog' inputName='log' if='inposterior(ExtendedBayesianSkyline.$(n))'/>

            <connect srcID='EBSPLogger' targetID='mcmc' inputName='logger' if='inposterior(ExtendedBayesianSkyline.$(n))'/>

            <connect srcID='bitflip.alltrees'            targetID='mcmc' inputName='operator' if='inposterior(ExtendedBayesianSkyline.$(n))'>EBSP bitflip operator</connect>
            <connect srcID='indicatorSampler.alltrees'   targetID='mcmc' inputName='operator' if='inposterior(ExtendedBayesianSkyline.$(n))'>EBSP indicator sampler</connect>
            <connect srcID='indicatorScaler.alltrees'    targetID='mcmc' inputName='operator' if='inposterior(ExtendedBayesianSkyline.$(n))'>EBSP population sizes </connect>
            <connect srcID='EBSPupDownOperator.alltrees' targetID='mcmc' inputName='operator' if='inposterior(ExtendedBayesianSkyline.$(n))'>Up/down scale substitution rates of EBSP prior and tree</connect>
        </subtemplate>

</mergewith>


<mergewith point='parametricDistributions'>
<!-- Parametric distributions, all without hyperpriors -->

<!-- Uniform -->
        <subtemplate id='Uniform' class='beast.math.distributions.Uniform' mainid='[top]'>
<![CDATA[
        <distr spec="beast.math.distributions.Uniform" lower='0' upper='Infinity'/>
]]>
        </subtemplate>

<!-- Normal -->
        <subtemplate id='Normal' class='beast.math.distributions.Normal' mainid='[top]'>
<![CDATA[
    <distr offset="0.0" spec="beast.math.distributions.Normal">
        <parameter name='mean' value='0' estimate='false'/>
        <parameter name='sigma' value='1' estimate='false'/>
    </distr>
]]>
        </subtemplate>

<!-- OneOnX -->
        <subtemplate id='1/X' class='beast.math.distributions.OneOnX' mainid='[top]'>
<![CDATA[
        <distr spec="beast.math.distributions.OneOnX"/>
]]>
        </subtemplate>

<!-- lognormal -->
        <subtemplate id='LogNormal' class='beast.math.distributions.LogNormalDistributionModel' mainid='[top]'>
<![CDATA[
        <distr name='distr' spec="beast.math.distributions.LogNormalDistributionModel">
            <parameter name='M' value="1" estimate='false'/>
            <parameter name='S' value="1.25" lower="0" upper="5" estimate='false'/>
        </distr>
]]>
        </subtemplate>

<!-- Exponential -->
        <subtemplate id='Exponential' class='beast.math.distributions.Exponential' mainid='[top]'>
<![CDATA[
        <distr offset="0.0" spec="beast.math.distributions.Exponential">
            <parameter name='lambda' value="1" estimate='false'/>
        </distr>
]]>
        </subtemplate>

<!-- Gamma -->
        <subtemplate id='Gamma' class='beast.math.distributions.Gamma' mainid='[top]'>
<![CDATA[
        <distr offset="0.0" spec="beast.math.distributions.Gamma">
            <parameter name='alpha' value="2" estimate='false'/>
            <parameter name='beta' value="2" estimate='false'/>
        </distr>
]]>
        </subtemplate>

<!-- Beta -->
        <subtemplate id='Beta' class='beast.math.distributions.Beta' mainid='[top]'>
<![CDATA[
        <distr offset="0.0" spec="beast.math.distributions.Beta">
            <parameter name='alpha' value="2" estimate='false'/>
            <parameter name='beta' value="2" estimate='false'/>
        </distr>
]]>
        </subtemplate>

<!-- Laplace -->
<!-- TODO: IMPLEMENT beast.math.distributions.LaplaceDistribution.getDistribution() before uncommenting this
-->
        <subtemplate id='LaplaceDistribution' class='beast.math.distributions.LaplaceDistribution' mainid='[top]'>
<![CDATA[
        <distr offset="0.0" spec="beast.math.distributions.LaplaceDistribution">
            <parameter name='mu' value="0" estimate='false'/>
            <parameter name='scale' value="1" estimate='false'/>
        </distr>
]]>
        </subtemplate>

<!-- InverseGamma -->
        <subtemplate id='InverseGamma' class='beast.math.distributions.InverseGamma' mainid='[top]'>
<![CDATA[
        <distr offset="0.0" spec="beast.math.distributions.InverseGamma">
            <parameter name='alpha' value="2" estimate='false'/>
            <parameter name='beta' value="2" estimate='false'/>
        </distr>
]]>
        </subtemplate>

</mergewith>



<!-- Tree initialisation -->
<!-- Random tree -->

        <subtemplate id='RandomTree' class='beast.evolution.tree.RandomTree' mainid='RandomTree.$(n)'>
<![CDATA[
            <tree spec='beast.evolution.tree.RandomTree' id='RandomTree.$(n)' estimate='false' trait='@datetrait.$(n)'>
                <taxa spec='Alignment' idref='data'/>
                <populationModel id='ConstantPopulation.$(n)' spec='ConstantPopulation'>
            		<popSize id='popSize.$(n)' spec='parameter.RealParameter' value='1'/>
	            </populationModel>
            </tree>
]]>
        </subtemplate>

<!-- Cluster tree (for UPGMA) -->

        <subtemplate id='UPGMATree' class='beast.util.ClusterTree' mainid='UPGMATree.$(n)'>
<![CDATA[
        <tree spec='beast.util.ClusterTree' id='UPGMATree.$(n)' clusterType='upgma' estimate='false'  trait='@datetrait.$(n)' taxa='@$(n)'/>
]]>
        </subtemplate>

<!-- Newick tree -->
        <subtemplate id='NewickTree' class='beast.util.ClusterTree' mainid='NewickTree.$(n)'>
<![CDATA[
        <tree spec='beast.util.TreeParser' id='NewickTree.$(n)' estimate='false'  trait='@datetrait.$(n)'  taxa='@$(n)' newick=""/>
]]>
        </subtemplate>

</beast>
